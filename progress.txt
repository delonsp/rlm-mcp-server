# Progress Log - RLM MCP Server Test Suite

Este arquivo registra o progresso do Ralph em cada iteração.

---

## Iteration 1 - Add pytest and pytest-asyncio to pyproject.toml

- What was implemented:
  - Added `[project.optional-dependencies]` section with `dev` group
  - Added pytest>=8.0.0 and pytest-asyncio>=0.24.0 as dev dependencies
  - Added `[tool.pytest.ini_options]` section with asyncio configuration

- Files changed:
  - pyproject.toml

- Learnings for future iterations:
  - pytest-asyncio requires `asyncio_default_fixture_loop_scope` config to avoid deprecation warning
  - Dev dependencies go in `[project.optional-dependencies]` section in modern pyproject.toml
  - Install with `pip install -e ".[dev]"` to get dev dependencies
  - pytest config can be added in `[tool.pytest.ini_options]` section
  - Setting `asyncio_mode = "auto"` makes async tests easier (no need for @pytest.mark.asyncio)

---

## Iteration 2 - Create tests/ directory with __init__.py

- What was implemented:
  - Created tests/ directory
  - Created tests/__init__.py with minimal header comment

- Files changed:
  - tests/__init__.py (new file)

- Learnings for future iterations:
  - pytest exit code 5 means "no tests collected" - this is expected for empty test suite
  - pytest correctly discovers the tests/ directory as a package

---

## Iteration 3 - Create tests/conftest.py with fixtures

- What was implemented:
  - Created tests/conftest.py with temp_db and sample_text fixtures
  - temp_db: Creates temporary SQLite .db file, cleans up after test
  - sample_text: Generates ~1.45M chars with Portuguese terms (medo, ansiedade, trabalho, etc.)
  - Added tests/test_fixtures.py to validate fixtures work correctly

- Files changed:
  - tests/conftest.py (new file)
  - tests/test_fixtures.py (new file)
  - PRD.md (marked task complete)

- Learnings for future iterations:
  - tempfile.mkstemp returns (file_descriptor, path) - must close fd before using path
  - sample_text of ~1.45M chars is well above the 100k threshold for auto-indexing
  - Fixtures in conftest.py are automatically discovered by pytest without imports

---

## Iteration 4 - Test save_variable and load_variable roundtrip

- What was implemented:
  - Created tests/test_persistence.py with TestSaveAndLoadVariable class
  - 10 test cases covering:
    - Roundtrip for string, dict, list types
    - Empty values (empty string, dict, list)
    - Nonexistent variable returns None
    - Variable with metadata
    - Overwriting existing variable
    - Large string (~1.45M chars) with compression

- Files changed:
  - tests/test_persistence.py (new file)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - PersistenceManager(db_path=temp_db) accepts custom path for testing
  - save_variable returns True on success, uses pickle + zlib compression
  - load_variable returns None if variable doesn't exist (not an exception)
  - INSERT OR REPLACE handles overwriting with same name

---

## Iteration 5 - Test delete_variable removes from database

- What was implemented:
  - Added TestDeleteVariable class to tests/test_persistence.py
  - 4 test cases covering:
    - Deleting an existing variable removes it from the database
    - Deleting a nonexistent variable returns True (SQLite DELETE succeeds)
    - Deleting a variable also removes its associated index
    - Deleting one variable doesn't affect other variables

- Files changed:
  - tests/test_persistence.py (added TestDeleteVariable class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - delete_variable removes both the variable AND its associated index (from indices table)
  - SQLite DELETE succeeds even if no rows match (no error thrown)
  - delete_variable returns True on success, False on exception

---

## Iteration 6 - Test list_variables returns correct metadata

- What was implemented:
  - Added TestListVariables class to tests/test_persistence.py
  - 7 test cases covering:
    - Empty database returns empty list
    - Returns all expected metadata fields (name, type, size_bytes, created_at, updated_at)
    - Correct type names for different types (str, dict, list, int)
    - Listing multiple variables
    - Results ordered by updated_at descending
    - size_bytes matches pickled size of original data
    - updated_at changes on overwrite while created_at stays same

- Files changed:
  - tests/test_persistence.py (added TestListVariables class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - list_variables returns list of dicts with keys: name, type, size_bytes, created_at, updated_at
  - Results are ordered by updated_at DESC (most recently modified first)
  - size_bytes is the pickled size before compression (not compressed size)
  - When a variable is overwritten, created_at is preserved via COALESCE in SQL

---

## Iteration 7 - Test save_index and load_index (roundtrip de índice semântico)

- What was implemented:
  - Added TestSaveAndLoadIndex class to tests/test_persistence.py
  - 9 test cases covering:
    - Roundtrip for simple index (term -> positions mapping)
    - Roundtrip for empty index
    - Loading nonexistent index returns None
    - Large index with 1000 terms (compression testing)
    - Overwriting existing index
    - Index without associated variable (foreign key not enforced)
    - Terms with special characters (Portuguese, symbols)
    - Position order preservation
    - Multiple indexes independence

- Files changed:
  - tests/test_persistence.py (added TestSaveAndLoadIndex class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - save_index stores dict with pickle + zlib compression (same as variables)
  - load_index returns None if index doesn't exist (not an exception)
  - SQLite foreign key on var_name is not enforced by default - indexes can exist without variables
  - INSERT OR REPLACE handles overwriting existing indexes
  - terms_count is stored in indices table (number of keys in the dict)

---

## Iteration 8 - Test clear_all removes all variables

- What was implemented:
  - Added TestClearAll class to tests/test_persistence.py
  - 7 test cases covering:
    - clear_all returns count of removed variables
    - clear_all removes all variables from database
    - clear_all removes all indices from database
    - clear_all on empty database returns 0
    - list_variables returns empty list after clear_all
    - Variables can be added after clear_all (database still functional)
    - clear_all preserves collections (only removes variables and indices)

- Files changed:
  - tests/test_persistence.py (added TestClearAll class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - clear_all returns int (count of removed variables), not boolean
  - clear_all only removes from variables and indices tables, not collections
  - collection_vars entries become orphaned but don't cause errors
  - After clear_all, database is fully functional for new operations

---

## Iteration 9 - Test get_stats returns correct counts

- What was implemented:
  - Added TestGetStats class to tests/test_persistence.py
  - 10 test cases covering:
    - get_stats on empty database returns zeros for counts
    - get_stats returns all expected keys (variables_count, variables_total_size, indices_count, total_indexed_terms, db_file_size, db_path)
    - Correct variables_count
    - Correct variables_total_size (sum of size_bytes)
    - Correct indices_count
    - Correct total_indexed_terms (sum of terms_count from all indices)
    - db_file_size matches actual file size on disk
    - db_path matches configured path
    - Stats return zeros after clear_all
    - Mixed data scenario with variables of different types and indices

- Files changed:
  - tests/test_persistence.py (added TestGetStats class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - get_stats returns dict with 6 keys
  - variables_total_size is sum of size_bytes (pickled size, not compressed)
  - total_indexed_terms is sum of terms_count (number of keys in index dict, not positions)
  - db_file_size reflects actual file size using os.path.getsize()
  - SQLite file size doesn't always change immediately after small writes (page caching)

---

## Iteration 10 - Test create_collection and list_collections

- What was implemented:
  - Added TestCreateCollectionAndListCollections class to tests/test_persistence.py
  - 13 test cases covering:
    - create_collection returns True on success
    - create_collection with description stores it correctly
    - create_collection without description stores None
    - create_collection sets created_at timestamp
    - create_collection overwrites existing but preserves created_at
    - list_collections on empty database returns empty list
    - list_collections returns correct fields (name, description, created_at, var_count)
    - list_collections with multiple collections
    - list_collections ordered alphabetically by name
    - var_count is 0 for empty collection
    - var_count reflects actual number of variables in collection
    - Collection with special characters in name and description
    - Multiple collections are independent

- Files changed:
  - tests/test_persistence.py (added TestCreateCollectionAndListCollections class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - create_collection uses INSERT OR REPLACE with COALESCE to preserve created_at on update
  - list_collections joins with collection_vars to get var_count using LEFT JOIN
  - list_collections orders by name ASC (alphabetical)
  - var_count uses COUNT(cv.var_name) which correctly counts 0 for empty collections
  - Collections support special characters in names (underscores, hyphens, numbers)

---

## Iteration 11 - Test add_to_collection and get_collection_vars

- What was implemented:
  - Added TestAddToCollectionAndGetCollectionVars class to tests/test_persistence.py
  - 14 test cases covering:
    - add_to_collection returns count of added variables
    - add_to_collection creates collection automatically if it doesn't exist
    - add_to_collection ignores duplicate variables (returns 0 for duplicates)
    - Partial duplicates scenario (mix of new and existing)
    - Adding empty list returns 0
    - Adding nonexistent variables works (foreign key not enforced)
    - add_to_collection sets added_at timestamp in ISO format
    - get_collection_vars returns list of variable names
    - get_collection_vars for empty collection returns empty list
    - get_collection_vars for nonexistent collection returns empty list
    - get_collection_vars returns variables ordered by name ASC
    - Adding same variable to multiple collections works
    - Adding many variables (50) at once
    - Special characters in variable names

- Files changed:
  - tests/test_persistence.py (added TestAddToCollectionAndGetCollectionVars class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - add_to_collection uses INSERT OR IGNORE to avoid duplicates
  - add_to_collection checks rowcount to track how many were actually added
  - add_to_collection auto-creates collection if it doesn't exist (avoids need for pre-create)
  - get_collection_vars returns variables ordered by var_name ASC
  - Foreign keys in SQLite are not enforced by default - variables can be added to collection even if they don't exist in variables table

---

## Iteration 12 - Test delete_collection removes associations but not variables

- What was implemented:
  - Added TestDeleteCollection class to tests/test_persistence.py
  - 10 test cases covering:
    - delete_collection returns True on success
    - delete_collection removes collection from database
    - delete_collection removes associations from collection_vars table (verified with direct SQL query)
    - delete_collection does NOT delete the variables themselves
    - Deleting nonexistent collection returns True
    - Deleting empty collection works
    - Deleting one collection doesn't affect other collections
    - Variables can be added to new collection after old collection is deleted
    - Deleting collection with shared variable doesn't affect other collections
    - Deleting collection with many variables (50)

- Files changed:
  - tests/test_persistence.py (added TestDeleteCollection class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - delete_collection deletes from both collection_vars and collections tables (in that order)
  - SQLite DELETE succeeds even if no rows match (no error thrown)
  - Variables are independent of collections - they persist after collection deletion
  - Same variable can be in multiple collections; deleting one collection doesn't affect others

---

## Iteration 13 - Test create_index gera índice com termos padrão

- What was implemented:
  - Created tests/test_indexer.py with TestCreateIndexWithDefaultTerms class
  - 17 test cases covering:
    - var_name is set correctly
    - total_chars calculated correctly
    - total_lines calculated correctly
    - Default terms present in text are indexed
    - Terms not in text are not indexed
    - Index entries contain line number (0-indexed)
    - Index entries contain context around the term
    - Case-insensitive matching (MEDO, Trabalho found as medo, trabalho)
    - Multiple occurrences on different lines
    - Avoids duplicates on same line
    - Empty text creates empty index (0 chars, 0 lines, no terms)
    - custom_terms is empty list by default
    - Emotion terms from DEFAULT_INDEX_TERMS are indexed
    - Relationship terms from DEFAULT_INDEX_TERMS are indexed
    - Body part terms from DEFAULT_INDEX_TERMS are indexed
    - context_chars parameter is respected
    - structure field is populated

- Files changed:
  - tests/test_indexer.py (new file)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - create_index uses splitlines() for total_lines - empty string returns 0, not 1
  - Terms are stored in lowercase in index.terms
  - Index uses case-insensitive matching for terms in text
  - Same line with multiple occurrences only creates one index entry
  - context_chars truncates the line content (uses line[:context_chars].strip())
  - DEFAULT_INDEX_TERMS is a set of ~70 Portuguese terms covering emotions, relationships, work, symptoms, body parts, and modalities

---

## Iteration 14 - Test create_index com additional_terms indexa termos customizados

- What was implemented:
  - Added TestCreateIndexWithAdditionalTerms class to tests/test_indexer.py
  - 13 test cases covering:
    - additional_terms are indexed when present in text
    - additional_terms are stored in custom_terms field
    - Case-insensitive matching for additional_terms
    - Uppercase terms in additional_terms list are normalized to lowercase for indexing
    - additional_terms are combined with DEFAULT_INDEX_TERMS
    - additional_terms not found in text are not indexed
    - Index entries have correct linha and contexto
    - Multiple occurrences create multiple entries
    - Empty list behaves like None (custom_terms == [])
    - Original case is preserved in custom_terms field
    - Portuguese special characters work correctly (cefaléia, diarréia)
    - Duplicate terms (in both default and additional) don't cause issues
    - Many custom terms (20) work correctly

- Files changed:
  - tests/test_indexer.py (added TestCreateIndexWithAdditionalTerms class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - additional_terms are normalized to lowercase via `t.lower()` before adding to terms_to_index set
  - custom_terms field preserves the original case from the input list
  - The set.update() method is used, so duplicates between default and additional terms are automatically handled
  - Empty additional_terms list results in custom_terms == [] (not None)

---

## Iteration 15 - Test TextIndex.search retorna matches corretos

- What was implemented:
  - Added TestTextIndexSearch class to tests/test_indexer.py
  - 13 test cases covering:
    - search returns list of matches for an indexed term
    - search returns empty list for term not in index
    - search is case-insensitive (converts input to lowercase)
    - search respects limit parameter (default 10)
    - search with limit=0 returns empty list
    - search results contain 'linha' key with line number
    - search results contain 'contexto' key with line context
    - search returns results in line order (ascending)
    - search works with custom terms added via additional_terms
    - search for empty string returns empty list
    - search on empty index returns empty list
    - search works with Portuguese special characters
    - search is read-only and doesn't modify the index

- Files changed:
  - tests/test_indexer.py (added TestTextIndexSearch class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - TextIndex.search converts input term to lowercase before looking up in self.terms
  - search uses list slicing [:limit] to cap results (Python slicing handles out-of-bounds gracefully)
  - Empty string search returns [] because "" is not a key in self.terms
  - search returns the actual list objects from self.terms (not copies), but doesn't modify them

---

## Iteration 16 - Test TextIndex.search_multiple with require_all=False (OR)

- What was implemented:
  - Added TestSearchMultipleOrMode class to tests/test_indexer.py
  - 13 test cases covering:
    - Returns dict with term -> matches for each found term
    - Omits terms not found in index
    - Returns empty dict when no terms are found
    - Case-insensitive search (search is lowercase but original term preserved as key)
    - Preserves original term case as dict key
    - Works with single term
    - Works with empty term list (returns {})
    - Multiple occurrences per term returned correctly
    - Matches contain linha and contexto keys
    - Works with custom terms from additional_terms
    - Returns empty dict on empty index
    - Handles many terms efficiently
    - Default require_all is False (OR mode)

- Files changed:
  - tests/test_indexer.py (added TestSearchMultipleOrMode class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - search_multiple with require_all=False uses dict comprehension: `{t: self.search(t) for t in terms if self.search(t)}`
  - The original term passed in is used as the dict key (preserves case), but search itself is case-insensitive
  - Empty list of terms returns {} (empty dict)
  - search_multiple defaults to require_all=False (OR mode) when not specified
  - OR mode returns dict[term, list[match]], AND mode (next task) returns dict[linha, list[terms]]

---

## Iteration 17 - Test TextIndex.search_multiple with require_all=True (AND)

- What was implemented:
  - Added TestSearchMultipleAndMode class to tests/test_indexer.py
  - 14 test cases covering:
    - Returns only lines containing ALL terms (require_all=True logic)
    - Returns dict with linha (int) as key, not term (string)
    - Returns list of found terms as value (lowercase)
    - Returns empty dict when no line has all terms
    - Returns empty dict when terms not found
    - Case-insensitive search
    - Terms in result are lowercase (per code: term.lower())
    - Multiple lines with all terms
    - Works with three or more terms
    - Works with single term
    - Empty term list returns empty dict
    - Works with custom terms from additional_terms
    - Returns empty dict on empty index
    - Confirms different structure from OR mode

- Files changed:
  - tests/test_indexer.py (added TestSearchMultipleAndMode class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - search_multiple with require_all=True uses defaultdict(set) to track terms per line
  - AND mode returns {linha: [terms]} while OR mode returns {term: [matches]}
  - The set comparison `found_terms == all_terms_set` ensures ALL terms must be present
  - Terms in AND mode result are stored as lowercase (via term.lower() when adding to set)
  - Empty term list causes all_terms_set to be empty, so no line can match (returns {})

---

## Iteration 18 - Test auto_index_if_large indexa apenas textos >= 100k chars

- What was implemented:
  - Added TestAutoIndexIfLarge class to tests/test_indexer.py
  - 13 test cases covering:
    - Returns TextIndex for text >= 100k chars (using sample_text fixture)
    - Returns None for text < 100k chars
    - Returns index at exactly 100000 chars
    - Returns None at 99999 chars (one char below threshold)
    - Custom lower min_chars threshold works
    - Custom higher min_chars threshold works
    - Empty text returns None (default threshold)
    - Empty text with min_chars=0 returns index
    - Index contains terms from text
    - Index has correct total_chars
    - Index has correct total_lines
    - Default threshold is confirmed to be 100000
    - Uses create_index internally (same structure)

- Files changed:
  - tests/test_indexer.py (added TestAutoIndexIfLarge class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - auto_index_if_large is a thin wrapper over create_index with a threshold check
  - Uses `>=` comparison: `if len(text) >= min_chars`
  - Default min_chars=100000 (100k chars)
  - Returns None for texts below threshold, TextIndex for texts at or above threshold
  - sample_text fixture from conftest.py is ~1.45M chars, perfect for testing this

---

## Iteration 19 - Test _detect_structure detecta headers markdown

- What was implemented:
  - Added TestDetectStructure class to tests/test_indexer.py
  - 20 test cases covering:
    - H1, H2, H3 markdown headers detection
    - Multiple headers at different levels
    - Correct line number recording for headers
    - Header title stripping of whitespace
    - Header title truncation at 100 chars
    - Empty text returns empty lists
    - Text without headers returns empty lists
    - Returns dict with headers, capitulos, remedios keys
    - Numeric chapter pattern like "4.8 Ferrum"
    - Multiple chapters detection
    - Chapter requires capital letter
    - "Quadro de" remedio pattern
    - Remedio with two word name
    - Multiple remedios detection
    - Combined headers, chapters, and remedios
    - Headers with special characters (Portuguese)
    - Empty header after hash symbols
    - Hash in middle of line is not detected

- Files changed:
  - tests/test_indexer.py (added TestDetectStructure class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - _detect_structure detects three patterns: markdown headers, numeric chapters, and "Quadro de" remedios
  - Header level is calculated via `len(line) - len(line.lstrip('#'))`
  - Title is truncated with `title[:100]`
  - Chapter regex: `r'^(\d+\.\d+)\s+([A-Z][a-zA-Z]+)'` - requires capital letter
  - Remedio regex: `r'Quadro de (\w+(?:\s+\w+)?)'` - captures 1-2 words

---

## Iteration 20 - Test TextIndex.to_dict and from_dict (serialização)

- What was implemented:
  - Added TestTextIndexSerialization class to tests/test_indexer.py
  - 25 test cases covering:
    - to_dict returns a dictionary
    - to_dict contains all expected keys (var_name, total_chars, total_lines, terms, structure, custom_terms)
    - to_dict preserves var_name, total_chars, total_lines correctly
    - to_dict preserves terms dictionary correctly
    - to_dict preserves structure correctly
    - to_dict preserves custom_terms correctly
    - to_dict works on empty index
    - from_dict returns a TextIndex instance
    - from_dict restores var_name, total_chars, total_lines correctly
    - from_dict restores terms dictionary correctly
    - from_dict restores structure correctly
    - from_dict restores custom_terms correctly
    - from_dict handles missing optional keys with defaults
    - Roundtrip test with simple index
    - Roundtrip test with custom terms
    - Roundtrip test with structure
    - Roundtrip test with empty index
    - Roundtrip test with large index (sample_text fixture)
    - Restored index search works
    - Restored index search_multiple works (both OR and AND modes)
    - Restored index get_stats works

- Files changed:
  - tests/test_indexer.py (added TestTextIndexSerialization class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - to_dict serializes all dataclass fields: var_name, total_chars, total_lines, terms, structure, custom_terms
  - from_dict uses data.get() with defaults for optional fields (terms={}, structure={}, custom_terms=[])
  - Required fields for from_dict: var_name, total_chars, total_lines
  - Restored TextIndex is fully functional (search, search_multiple, get_stats all work)
  - Roundtrip tests (to_dict -> from_dict) are important for verifying serialization integrity

---

## Iteration 21 - Test execute com código simples (print, atribuição)

- What was implemented:
  - Created tests/test_repl.py with TestExecuteSimpleCode class
  - 23 test cases covering:
    - execute returns ExecutionResult object
    - execute returns success=True for valid code
    - execute captures print output in stdout
    - execute captures multiple print statements
    - execute records assigned variable in variables_changed
    - execute handles multiple assignments
    - execute handles string, list, dict assignments
    - execute handles arithmetic operations
    - execute handles string operations
    - execute handles list comprehension
    - execute handles function definition and call
    - execute returns execution_time_ms >= 0
    - execute returns success=False for syntax error
    - execute returns success=False for runtime error (ZeroDivisionError)
    - execute returns success=False for NameError
    - execute increments execution_count
    - execute handles empty code
    - execute handles code with only comments
    - execute creates variable metadata
    - execute creates variable metadata with preview

- Files changed:
  - tests/test_repl.py (new file)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - SafeREPL() injects llm_query, llm_stats, llm_reset_counter into namespace on every execute()
  - These llm_* functions always appear in variables_changed because bound methods create new objects on each access
  - To check user variables only, filter: `[v for v in variables_changed if not v.startswith("llm_")]`
  - execute() captures stdout/stderr by temporarily replacing sys.stdout/sys.stderr
  - Syntax errors are caught in _validate_code and return SecurityError message
  - execution_count is incremented even on failed executions
  - variable_metadata stores VariableInfo with name, type_name, size_bytes, size_human, preview, created_at, last_accessed

---

## Iteration 22 - Test execute preserva variáveis entre execuções

- What was implemented:
  - Added TestExecutePreservesVariables class to tests/test_repl.py
  - 20 test cases covering:
    - Variable from first execution available in second
    - Multiple variables persist across executions
    - Variable can be modified in subsequent executions
    - List variable persists and can be modified (append)
    - Dict variable persists and can be modified (key assignment)
    - Function defined in first execution callable in second
    - Class definition not supported in sandbox (__build_class__ not exposed)
    - Imported module persists (e.g., statistics module)
    - repl.variables property reflects current state
    - del in namespace doesn't remove from repl.variables (tracked separately)
    - Variable metadata persists (created_at preserved on update)
    - Failed execution does not lose existing variables
    - Partial execution preserves variables defined before error
    - Variables isolated between different SafeREPL instances
    - Complex nested data structures persist
    - Generator expression result persists (when converted to list)
    - String operations work across executions
    - Lambda functions persist and can be used
    - Many executions (20 variables) preserve all variables
    - llm_query, llm_stats, llm_reset_counter always available

- Files changed:
  - tests/test_repl.py (added TestExecutePreservesVariables class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - SafeREPL persists variables via self.variables dict, injected into namespace with **self.variables
  - Classes don't work in sandbox because __build_class__ builtin is not exposed (security feature)
  - del x in executed code doesn't remove from repl.variables - it's only synced on new/changed
  - Functions defined with def persist between executions
  - Lambdas persist between executions
  - Modules imported in one execution are available in subsequent (via self.variables)
  - created_at is preserved when variable is updated (uses existing metadata)
  - Each SafeREPL instance has independent variable storage

---

## Iteration 23 - Test execute blocks dangerous imports (os, subprocess, socket)

- What was implemented:
  - Added TestExecuteBlocksDangerousImports class to tests/test_repl.py
  - 24 test cases covering:
    - Import os, subprocess, socket, sys, shutil are blocked
    - Import pathlib, http, urllib, requests are blocked
    - Import pickle, sqlite3 are blocked
    - Import multiprocessing, threading, concurrent are blocked
    - Import ctypes, importlib, builtins are blocked
    - from X import Y syntax is also blocked (e.g., from os import system)
    - Import os.path is blocked (base module check)
    - Blocked import doesn't modify namespace
    - Error message mentions "bloqueado" (blocked in Portuguese)
    - Unknown modules not in whitelist are also blocked with different error message
    - Blocked import in try-except can be caught BUT module is never loaded
    - Multiple dangerous imports tested in loop

- Files changed:
  - tests/test_repl.py (added TestExecuteBlocksDangerousImports class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - _safe_import checks base module (name.split('.')[0]) against BLOCKED_IMPORTS first
  - If blocked, raises SecurityError: "Import bloqueado por seguranca: 'X'"
  - If not in ALLOWED_IMPORTS, raises SecurityError: "Import nao permitido: 'X'. Permitidos: ..."
  - SecurityError is a custom exception defined in repl.py
  - Try-except in user code CAN catch SecurityError - module is never loaded, user gets exception
  - This is correct behavior: security is maintained, user can handle gracefully if desired
  - BLOCKED_IMPORTS includes: os, sys, subprocess, shutil, pathlib, socket, http, urllib, requests, httpx, pickle, shelve, sqlite3, multiprocessing, threading, concurrent, ctypes, cffi, importlib, builtins, __builtins__

---

## Iteration 24 - Test execute permite imports seguros (re, json, math, collections)

- What was implemented:
  - Added TestExecuteAllowsSafeImports class to tests/test_repl.py
  - 30 test cases covering:
    - import re, json, math, collections are allowed (pre-imported modules)
    - import statistics, itertools, functools, operator, string are allowed
    - import textwrap, datetime, time, calendar are allowed
    - import dataclasses, typing, enum are allowed
    - import csv, hashlib, base64 are allowed
    - import gzip, zipfile are allowed
    - import unicodedata is allowed
    - from X import Y syntax is allowed (from collections import Counter, etc.)
    - Pre-imported modules available without explicit import statement
    - Safe imports persist for subsequent executions
    - Multiple safe imports tested in loop
    - Non-preimported modules ARE tracked in self.variables
    - Safe import doesn't produce security error message

- Files changed:
  - tests/test_repl.py (added TestExecuteAllowsSafeImports class)
  - PRD.md (marked task complete)
  - progress.txt

- Learnings for future iterations:
  - Modules re, json, math, collections, datetime are pre-imported into namespace (lines 298-302 in repl.py)
  - Pre-imported modules are EXCLUDED from self.variables tracking (lines 334-337 checks name against these)
  - Non-pre-imported modules (statistics, itertools, etc.) ARE tracked in self.variables
  - ALLOWED_IMPORTS set contains ~25 safe modules: re, json, math, statistics, collections, itertools, functools, operator, string, textwrap, unicodedata, datetime, time, calendar, dataclasses, typing, enum, csv, html, xml.etree.ElementTree, hashlib, base64, gzip, zipfile, tarfile
  - _safe_import allows base_module if it's in ALLOWED_IMPORTS

---

